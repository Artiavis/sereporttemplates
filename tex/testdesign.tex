\chapter{Design of Tests}

% Describe the way we plan on performing our
% tests and why it'll kick everyone's asses
% --------- No pseudocode needed -----------
No application is complete until it has been tested
as thoroughly as possible for security holes, broken
functionality, and any other lacking features.
Shipping without testing is a guarantee to have
all manner of bugs and security holes. However, even
with thorough testing, it is not usually possible to
find and resolve every flaw before shipment. To this end,
developers utilize \emph{testing suites} to try and
test programs efficiently and effectively. Tests can be
designed for individual units and components as well as
the broader system and the integration of the units.
While not perfect for finding all flaws in a program
(usually errors are discovered by looking
for them, which generally requires either knowledge of an
existing error or ``luck'' in an error making itself
apparent during development), testing can serve to find
almost all errors and flaws in an application.

However, developers face a dilemma. Developing an
evolving application can cause existing tests to
become outdated, while designing and running tests
is time taken away from actually building the application.

A modern approach to this tradeoff is to build the
feature set of an application around measurable,
predefined tests. \cite{wiki:tdd} In this technique,
known as Test-driven Development, developers iteratively
define tests for intended future features, confirm that those
features are not yet implemented (by running those tests),
and then implementing the solutions. Though this approach
does not (generally) test for all possible interplay
between components, it is usually employed in high-paced
development environments such as ours, where the coverage provided is
usually respectable enough to prevent most problems.

Accordingly, we first define the features and tests we
plan on developing around, proceed to analyze the coverage
offered by these tests, and then briefly discuss how we
intend to test the integration of the components.

% list and describe the test cases that will
% be programmed and used for unit testing
\section{Test Cases}

Due to project constraints, we cannot afford to thoroughly
test existing packages for functionality we incorporated to
streamline the design process. These packages include Ruby
on Rails
as well as Ruby gems (packages) for interfacing with Yahoo! Finance,
various databases (ie MySQL, SQLite), the Resque queueing system,
and other auxilliary package for Rails. Likewise, we
cannot unit test
the HTTP server we are using (Apache) and its Ruby 
extension (Phusion Passenger) or any of the databases. Rather
we will focus on testing just the units of our application and
their integration with each other.

% Discuss checking the routing, ie that all routes and permissions
% are enforced
\subsection{Routing}

As described earlier, Capital Games contains models for
users, managers, administrators, trades, etc. Intrinsic to the Rails web framework
we employ, most of these models are represented internally to the 
controller as ``resources''. \cite{guides:routing} At any
point in time, any user (even a non-user!) could attempt to gain
access to a resource to which they are not privileged, such as an
administrator panel. Routing unit tests will confirm that only
authorized users will be able to access restricted pages. As an
extension of this premise, Routing unit tests will also confirm
that pages with low privileges are accessible to all users and
front-facing pages can be seen even without being logged in.

% Discuss that Rails does autmoatic validation but we have to test
% this anyway since it's so important
\subsection{Database Models}

Because of the data-centric design of Capital Games, protecting the
integrity of the database entries is of the utmost importance. The
Ruby on Rails framework has safeguards and validation for this purpose,
but we still need to thoroughly unit test each of the models to ensure
that only permissible combinations of attributes are able to be entered,
and that proper error handling occurs to resolve attempts at improper
attribute definition.

\subsection{Queueing System}

\subsection{Finance Adaptor}

% Describe the test coverage
\section{Test Coverage}

% Describe integration testing strategy
\section{Integration Testing}