\section{Web Server Administration}

In order to achieve full site functionality with Capitalgam.es much configuration was necessary to ensure that each individual part integrates successfully into one cohesive unit. We chose to host our website using a VPS(Virtual Private Server) hosted by ChicagoVPS, purchased the domain name Capitalgam.es from en.gandi.net, and used Amazon's Route 53 as our Domain Name System. Our host came preconfigured with Debian 6(Squeeze).  Having years of experience using Ubuntu and other user level Linux distro's it was an easy transition to learn the ins and outs of Debian as it is the parent of Ubuntu.  I will now walk through the configuration process that was necessary to get Capitalgam.es to successfully deploy in production mode.

The first things necessary install were apache2, and ruby. While apache2 can easily be installed using apt-get, our group is working with a very specific version of ruby, by first installing RVM (Ruby Version Manager) we were able to select the specific version of ruby (1.9.3) that we developed in.  After installing ruby, the next installation was RubyGems, which handles all required Ruby package installations.
Rails does not naturally integrate into apache2, in order to facilitate this integration Phusion Passenger is needed.  After installing the Phusion Passenger gem using RubyGems, the apache2 configuration file needed to be modified to specify the passenger module locations for when apache2 looks for passenger after reading the Virtual Host file.

For any site running on apache2, a virtual host file is required in order to direct apache2 to the correct directory based on the port the server is being accessed from (port 80 by default).  With the Phusion Passenger configuration set for passenger module use, it was just necessary to add the app path to the virtual host file and then use the standard apache2 command a2ensite then service restart apache2 to enable it.  By using github, our team was easily able to update our webapp locally on our own computers, push it to github, and then pulls it back down onto the server.  By having the git repository in the same directory that the virtual host is pointed to, all that was needed at this point was having mysql installed, properly configured, and pointed to by the /config/database.yml file in our webapp.  Using the command passenger start –e production –d started our app in production mode detached as a daemon which allowed us to have the webapp run 24/7 as a background process unowned by a user which is vital to ensuring the process doesn’t die on user logout.

A large problem faced while detaching processes with passenger is the way the daemons are tracked.  When a detached passenger session is launched a .pid file is generated in the current directory.  This .pid file contains the process ID of the daemon.  Without this file passenger will not be able to stop the server as it does not know the process ID of the server.  When first working with passenger I had been launching the server from locations that did not have write access.  This caused the PID files never to generate and created a large obstacle when we wanted to take down the server.  The solution to our problem came out of using the ps –aux command to manually locate the daemons needed to be killed then using the kill -9 system call to kill them.


\section{Production Database Administration}

In production we used MySQL2 along with the MySQL gem, as previously stated this was specified in /config/database.yml of our webapp. We have our login defaulted to Username: root Password: none due to us not having front end access directly to the server, the Database can only be accessed after first authenticating through SSH which is secure. 